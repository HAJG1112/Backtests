import bt
import pandas as pd
import matplotlib.pyplot as plt
from sklearn import preprocessing
import numpy as np

class vci():

    def __init__(self, ticker, start, end,
                 macd_n, macd_m,
                 rsi_n,rsi_m,
                 so_n, so_m,
                 fc_window):

        self.ticker = ticker #defines the ticker symbol
        self.start = start  #start date of backtest
        self.end = end    #ends backtest
        self.prices = bt.get(self.ticker, start = self.start, end = self.end) #initialize getting prices according to ticker
        self.macd_n = macd_n       #MACD short sma window
        self.macd_m = macd_m        #MACD long sma window
        self.rsi_n = rsi_n
        self.rsi_m = rsi_m
        self.so_n = so_n
        self.so_m = so_m
        self.fc_window = fc_window


    def above_macd(self):
        short_sma = self.prices.rolling(self.macd_n).mean()
        long_sma = self.prices.rolling(self.macd_m).mean()
        macd = (short_sma - long_sma)
        return (macd)

    def scaler(self,x):
        data = pd.DataFrame(x).rolling(window = 252)  #252 day rolling window    #.iloc[252:]#
        scaler = preprocessing.MinMaxScaler(feature_range=(-1, 1))   #we take this window and rescale
        df_scaled = pd.DataFrame(scaler.fit_transform(data))   #distribution for comparison
        #today = length of distribution +1 in position
        #take todays value, and compare it to distribution to get todays weight,
        #take all of 'todays' weights and create weight dataframe
        #this weighted dataframe is then used in the backtest
        return(df_scaled)
    
   def scaler1(self,x):
        data = x.copy()
        min = -1 #min weight
        max = 1 #max weight
        data = pd.DataFrame(data).rolling(window = 252)  #252 day rolling window    .iloc[252:]

        today = data.iloc[len(data)+1:]   #this is the position of today
        today_std = (today - data.min(axis=0)) / (data.max(axis=0) - data.min(axis=0))
        scale = (max - min) / (data.max(axis=0) - data.min(axis=0))
        today_scaled = scale * today + min - data.min(axis=0) * scale
        
        return(today_scaled)
    def wrapper(self):   #wraps the weights to be parsed into the strategy
        macd = self.above_macd()
        signal = macd.copy()
        tw = pd.DataFrame(self.scaler(signal))    #this makes the trading weights
        return tw


ticker = 'spy'
start = '2013-01-01'
end = '2018-06-06'
macd_n = 10
macd_m = 26
rsi_n = 14
rsi_m = 10
so_n = 14
so_m = 3
fc_window = 252
i = vci(ticker, start, end,
                 macd_n, macd_m,
                 rsi_n,rsi_m,
                 so_n, so_m, fc_window)

data = bt.get('spy')
print(i.wrapper())


'''
s = bt.Strategy('weights',
                        [bt.algos.WeighTarget(i.wrapper()),
                         bt.algos.Rebalance()],
                        [ticker])
t = bt.Backtest(s,data)

res = bt.run(t)
'''
