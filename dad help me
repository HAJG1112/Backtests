import bt
import pandas as pd
import matplotlib.pyplot as plt
from sklearn import preprocessing
import numpy as np

class vci():

    def __init__(self, ticker, start, end,
                 macd_n, macd_m,
                 rsi_n,rsi_m,
                 so_n, so_m,
                 fc_window):

        self.ticker = ticker #defines the ticker symbol
        self.start = start  #start date of backtest
        self.end = end    #ends backtest
        self.macd_n = macd_n       #MACD short sma window
        self.macd_m = macd_m        #MACD long sma window
        self.rsi_n = rsi_n
        self.rsi_m = rsi_m
        self.so_n = so_n
        self.so_m = so_m
        self.fc_window = fc_window


    def above_macd(self,x):
        short_sma = x.rolling(self.macd_n).mean()
        long_sma = x.rolling(self.macd_m).mean()
        macd = (short_sma - long_sma)
        return (macd)

    def prepare(self, indicator):
        w = fc_window # default window size
        f = indicator.copy()  # copy dataframe to ensure original is not affected
        # create two columns for min and max
        f['+min+'] = f[self.ticker].rolling(w).min()  # error in these two lines
        f['+max+'] = f[self.ticker].rolling(w).max()
        # further columns for scaled and tranformed
        f['+sv+'] = np.nan
        f['+trans+'] = np.nan
        return f
        pass

    def scaler(self, indicator):
        f = self.prepare(indicator)
        minW = -1  # min weight
        maxW = 1  # max weight
        for i in range(len(f)):
            cv = (f.iloc[i][0])
            min_prev = (f.iloc[i-1]['+min+'])
            max_prev = (f.iloc[i-1]['+max+'])
            sv = (cv - min_prev)/(max_prev - min_prev)  # scaled value calculation
            sv = (sv * 2)-1
            t = maxW if sv > maxW else minW if sv < minW else sv # transformed calculation
            f['+sv+'][i] = sv
            f['+trans+'][i] = t
            pass

    def wrapper(self,x):   #wraps the weights to be parsed into the strategy
        macd = self.above_macd(x)
        tw = pd.DataFrame(self.scaler(macd))    #this makes the trading weights
        return tw



ticker = 'spy'
start = '2013-01-01'
end = '2018-06-06'
macd_n = 10
macd_m = 26
rsi_n = 14
rsi_m = 10
so_n = 14
so_m = 3
fc_window = 252
i = vci(ticker, start, end,
                 macd_n, macd_m,
                 rsi_n,rsi_m,
                 so_n, so_m, fc_window)

data = bt.get('spy',start = start,end = end)

print(i.wrapper(data))



'''
s = bt.Strategy('weights',
                        [bt.algos.WeighTarget(i.wrapper()),
                        bt.algos.RunAfterDays(260),   #this lets our dataframe for weight allocation fill first
                         bt.algos.Rebalance()],
                        [ticker])
t = bt.Backtest(s,data)

res = bt.run(t)
'''

#use df to store data
#df to store weights
#create variable to store weights, list or array
